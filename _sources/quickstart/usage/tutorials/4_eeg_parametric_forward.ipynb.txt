{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Solve EEG parametric forward problem\n",
    "\n",
    "In this example, we go through the process of solving EEG parametric forward problem for the model generated in [this example](1_model_creation.ipynb). The result of this process is a `EEGParametricForwardSolution` which can be used to generate any `EEGForwardSolution` or leadfield matrix based on a set of parameters.\n",
    "\n",
    "## Model loading\n",
    "\n",
    "As for [this example](2_eeg_forward.ipynb), we first have to load the previously generated `FEModel`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from shamo import FEModel\n",
    "\n",
    "model_name = \"model\"\n",
    "model_path = Path((\"./derivatives/1_model_creation/{name}\"\n",
    "                   \"/{name}.json\").format(name=model_name))\n",
    "model = FEModel.load(model_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The model can now be used to generate the parametric leadfield matrix.\n",
    "\n",
    "## Problem definition\n",
    "\n",
    "To generate an `EEGParametricForwardSolution`, we must create an `EEGParametricForwardProblem`. The exact same steps are used to define this problem:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'regions_of_interest': ['b', 'c'],\n",
       " 'markers': ['C', 'G'],\n",
       " 'electrical_conductivity': {},\n",
       " 'reference': 'A'}"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from shamo import EEGParametricForwardProblem\n",
    "\n",
    "problem = EEGParametricForwardProblem()\n",
    "\n",
    "# Set reference\n",
    "problem.set_reference(\"A\")\n",
    "\n",
    "# Add markers\n",
    "problem.add_markers([\"C\", \"G\"])\n",
    "\n",
    "# Add regions of interest\n",
    "problem.add_regions_of_interest([\"b\", \"c\"])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The only thing that changes here is how we define the electrical conductivity of the tissues. Indeed, as we want them to be parametric, we have to provide the problem with distributions for their values. The available distributions are:\n",
    "- `ConstantDistribution`: It defines a fixed variable and only takes one parameter which is the value.\n",
    "- `TruncatedNormalDistribution`: It defines a bounded normal distribution.\n",
    "- `UniformDistribution`: It defines a uniform distribution and takes two parameters (its min and max values).\n",
    "\n",
    "As for the `EEGForwardProblem`, we can specify an anisotropic field for each tissue."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'regions_of_interest': ['b', 'c'],\n",
       " 'markers': ['C', 'G'],\n",
       " 'electrical_conductivity': {'a': {'value': {'name': 'constant', 'value': 1.0},\n",
       "   'anisotropy': ''},\n",
       "  'c': {'value': {'name': 'uniform', 'minimum': 0.25, 'maximum': 0.75},\n",
       "   'anisotropy': ''},\n",
       "  'b': {'value': {'name': 'uniform', 'minimum': 0.1, 'maximum': 0.9},\n",
       "   'anisotropy': 'b_anisotropy'}},\n",
       " 'reference': 'A'}"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from shamo import ConstantDistribution, UniformDistribution\n",
    "\n",
    "problem.set_electrical_conductivities({\"a\": ConstantDistribution(1.0), \"c\": UniformDistribution(0.25, 0.75)})\n",
    "problem.set_electrical_conductivity(\"b\", UniformDistribution(0.1, 0.9), \"b_anisotropy\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Problem resolution\n",
    "\n",
    "Finally, we can solve the problem. This solver can accept more arguments. For instance, we can provide a `method` argument which defines how we want to solve the problem:\n",
    "- `METHOD_SEQ` to use only one core.\n",
    "- `METHOD_MULTI` to use multiple cores on a single machine.\n",
    "- `METHOD_MPI` to use multiple cores on a distributed system.\n",
    "- `METHOD_JOBS` to generate one python script by sub-problem. Those scripts can then be run to generate separate `EEGForwardSolution`. When using this method, you must call the `finalize()` method after loading the solution to allow it to discover the sub-solutions and generate the surrogate model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "solution = problem.solve(\"parametric_solution\", \n",
    "                         \"./derivatives/4_eeg_parametric_forward\", model,\n",
    "                         method=EEGParametricForwardProblem.METHOD_MULTI,\n",
    "                         n_evals=10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Surrogate model usage\n",
    "\n",
    "Once the `EEGParametricForwardSolution` is properly generated and that `finalize()` have been called, we can use it to produce arbitrary `EEGForwardSolution` and leadfield matrix.\n",
    "\n",
    "For instance, we can create a solution which has a certain set of electrical conductivities by using the `generate_solution()` method."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "arbitrary_solution = solution.generate_solution(\"solution\", \"./derivatives/4_eeg_parametric_forward\", \n",
    "                                                c=0.35, b=0.62)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The resulting `EEGForwardSolution` can be used just like any other to evaluate a source vector or for further computations.\n",
    "\n",
    "It is also possible to generate only the matrix by using the `generate_matrix()` method."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "arbitrary_matrix = solution.generate_matrix(c=0.35, b=0.62)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
